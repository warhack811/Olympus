# app/orchestrator_v42/plugins/runtime_policy.py

import logging
import time
from typing import List, Dict, Any, Optional
from app.orchestrator_v42.plugins.runtime_state import RuntimeState

logger = logging.getLogger("orchestrator.policy")

def choose_key_and_limits(
    state: RuntimeState,
    available_keys: List[str],
    selected_model_id: str,
    now_ts: float
) -> Dict[str, Any]:
    """
    Çalışma Zamanı Politikası (Runtime Policy).
    
    Verilen durum (state) ve kullanılabilir anahtarlar arasından en uygununu seçer.
    """
    # 1. Anahtar Kontrolü
    if not available_keys:
        return {
            "selected_key_id": "yok",
            "max_key_attempts": 0,
            "cooldown_seconds": 0,
            "timeout_seconds": 0,
            "circuit_breaker_open": False,
            "reason": "taslak: kullanılabilir anahtar havuzu boş"
        }
    
    # State'i güncelle
    for k in available_keys:
        state._ensure_key(k)
        
    # 2. Adayları Belirle (Filtreleme)
    candidates = []
    for key_id in available_keys:
        if state.is_in_cooldown(key_id, now_ts):
            continue
        if state.is_circuit_open(key_id, now_ts):
            continue
        candidates.append(key_id)
        
    best_key = None
    reason = ""
    
    if not candidates:
        # Acil Durum Seçimi: candidates boşsa, available_keys içinden alfabetik ilkini seç
        # Sort edip ilkini alıyoruz ki deterministik olsun
        sorted_all = sorted(available_keys)
        best_key = sorted_all[0]
        reason = "taslak: tüm anahtarlar kısıtlı, acil durum seçimi"
    else:
        # 3. Puanlama ve Seçim
        # Score = (error_count * 10) + rpm
        # Eşitlikte alfabetik küçük key_id
        
        # Tuple (score, key_id) oluşturup min() alacağız
        scored_candidates = []
        for key_id in candidates:
            key_data = state.keys.get(key_id, {})
            error_count = key_data.get("error_count", 0)
            rpm = key_data.get("rpm", 0)
            score = (error_count * 10) + rpm
            scored_candidates.append((score, key_id))
            
        # Min, tuple'ın ilk elemanına (score) bakar, eşitse ikinciye (key_id) bakar -> Deterministik
        best_score, best_key = min(scored_candidates)
        reason = "taslak: en az yüklü ve uygun anahtar"

    # 4. Timeout Belirleme (Deterministik Tablo)
    timeout_map = {
        "genel_hizli_v1": 15,
        "genel_dengeli_v1": 25,
        "kod_odakli_v1": 35
    }
    # Varsayılan 25
    timeout = timeout_map.get(selected_model_id, 25)
    
    # Prefix/Substring kontrolü (istenirse, ama şimdilik tam eşleşme veya default)
    # Eğer map'te yoksa ve kod içeriyorsa gibi ek kurallar eklenebilir ama 
    # şu an user isteği üzerine deterministik basit sözlük yeterli.
    
    # 5. Devre Kesici Durumu (Raporlama için)
    is_open = state.is_circuit_open(best_key, now_ts)
    
    return {
        "selected_key_id": best_key,
        "max_key_attempts": 2, # Sabit
        "cooldown_seconds": 20, # Sabit
        "timeout_seconds": timeout,
        "circuit_breaker_open": is_open,
        "reason": reason
    }
