# app/orchestrator_v42/plugins/runtime_policy.py

import logging
import time
from typing import List, Dict, Any, Optional
from app.orchestrator_v42.plugins.runtime_state import RuntimeState

logger = logging.getLogger("orchestrator.policy")

def choose_key_and_limits(
    state: RuntimeState,
    available_keys: List[str],
    selected_model_id: str,
    now_ts: float
) -> Dict[str, Any]:
    """
    Çalışma Zamanı Politikası (Runtime Policy).
    
    Verilen durum (state) ve kullanılabilir anahtarlar arasından en uygununu seçer.
    Ayrıca zaman aşımı (timeout) ve tekrar deneme (retry) limitlerini belirler.
    
    Kurallar:
    - Anahtar Yoksa: Hata/Boş dönüş.
    - Filtreleme: Cooldown'da olan veya Devre Kesicisi açık olanları ele.
    - Puanlama: (Hata Sayısı * 10) + RPM. En düşük puan en iyidir.
    - Eşitlik (Tie-break): Alfabetik küçük Key ID.
    - Timeout: Model tipine göre deterministik süre (Hızlı: 15s, Kod: 35s, Diğer: 25s).
    """
    # 1. Anahtar Kontrolü
    if not available_keys:
        return {
            "selected_key_id": "yok",
            "max_key_attempts": 0,
            "cooldown_seconds": 0,
            "timeout_seconds": 0,
            "circuit_breaker_open": False,
            "reason": "taslak: kullanılabilir anahtar havuzu boş"
        }
    
    # State'i güncelle (yeni anahtarları tanı)
    for k in available_keys:
        state._ensure_key(k)
        
    # 2. Adayları Belirle (Filtreleme)
    candidates = []
    for key_id in available_keys:
        # State verisini kontrol et
        if state.is_in_cooldown(key_id, now_ts):
            continue
        if state.is_circuit_open(key_id, now_ts):
            continue
        candidates.append(key_id)
        
    # Eğer tüm adaylar elendiyse, en az kötü olanı (örneğin cooldown'u en yakın bitecek olanı) seçmek gerekebilir 
    # veya direkt hata dönülebilir. Şimdilik ilk anahtarı "zorla" seçelim ama limitli.
    if not candidates:
        logger.warning("Tüm anahtarlar meşgul veya kısıtlı! İlk anahtar zorla seçiliyor.")
        best_key = available_keys[0]
        reason = "taslak: tüm anahtarlar kısıtlı, acil durum seçimi"
    else:
        # 3. Puanlama ve Seçim
        best_key = None
        best_score = 999999
        
        for key_id in candidates:
            # Veriyi state'ten al
            # Erişim garantisi için _ensure_key yukarıda yapıldı
            key_data = state.keys.get(key_id, {})
            error_count = key_data.get("error_count", 0)
            rpm = key_data.get("rpm", 0)
            
            # Puanlama Formülü: Hata ağırlıklı yük dengesi
            score = (error_count * 10) + rpm
            
            is_better = False
            if score < best_score:
                is_better = True
            elif score == best_score:
                # Eşitlikte alfabetik öncelik
                if best_key is None or key_id < best_key:
                    is_better = True
            
            if is_better:
                best_score = score
                best_key = key_id
        
        reason = "taslak: en az yüklü ve uygun anahtar"

    if not best_key:
        best_key = "varsayilan_anahtar" # Teorik olarak ulaşılamaz

    # 4. Timeout Belirleme (Model Bazlı)
    timeout = 25 # Varsayılan
    if "hizli" in selected_model_id:
        timeout = 15
    elif "kod" in selected_model_id:
        timeout = 35
    
    # 5. Devre Kesici Durumu (Raporlama için)
    is_open = state.is_circuit_open(best_key, now_ts)
    
    return {
        "selected_key_id": best_key,
        "max_key_attempts": 2, # Sabit
        "cooldown_seconds": 20, # Sabit (Hata durumunda uygulanacak süre)
        "timeout_seconds": timeout,
        "circuit_breaker_open": is_open,
        "reason": reason
    }
