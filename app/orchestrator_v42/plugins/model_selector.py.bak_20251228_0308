# app/orchestrator_v42/plugins/model_selector.py

import logging
from typing import List, Dict, Any

logger = logging.getLogger("orchestrator.selector")

def select(required_capabilities: List[str], catalog: List[Dict[str, Any]]) -> Dict[str, Any]:
    """
    Model Seçici (Model Selector).
    
    Gereken yeteneklerle katalogdaki modelleri eşleştirir ve en uygun modeli seçer.
    
    Kurallar:
    - Katalog boşsa güvenli varsayılan döner.
    - Puanlama: Eşleşme (+2), Eksik (-3).
    - Tier Bonusları: Deterministik (Hızlı +1, Dengeli +2, Derin +3, Uzman +2, Yerel +1).
    - Eşitlik Durumu (Tie-break): model_id alfabetik sırasına göre küçük olan seçilir.
    """
    logger.debug(f"Model seçimi yapılıyor. Gereksinimler: {required_capabilities}")
    
    # 1. Katalog Boşsa Güvenli Fallback
    if not catalog:
        logger.warning("Katalog boş geldi! Varsayılan modele dönülüyor.")
        return {
            "selected_model_id": "genel_dengeli_v1",
            "score": 0,
            "candidates_considered": 0,
            "reason": "taslak: katalog boş, varsayılana dönüldü"
        }
    
    best_model = None
    best_score = -9999
    
    # Sabit Tier Bonusları
    tier_bonus_map = {
        "hizli": 1,
        "yerel": 1,
        "dengeli": 2,
        "uzman": 2,
        "yaratici": 2,
        "derin": 3
    }
    
    # 2. Puanlama Algoritması
    for model in catalog:
        score = 0
        model_caps = model.get("capabilities", [])
        
        # Yetenek Eşleşmesi
        for req in required_capabilities:
            if req in model_caps:
                score += 2 # Eşleşen her yetenek için ödül
            else:
                score -= 3 # Eksik yetenek için ceza
        
        # Tier Bonusu
        tier = model.get("tier", "bilinmiyor")
        score += tier_bonus_map.get(tier, 0)
            
        # 3. Kıyaslama ve Tie-break (Eşitlik bozma)
        is_better = False
        if score > best_score:
            is_better = True
        elif score == best_score:
            # Eşit puanda alfabetik olarak önde olana (küçük olana) öncelik ver
            # Bu sayede seçim her zaman deterministik olur (sıralamaya bağlı kalmaz)
            current_id = model.get("model_id", "")
            best_id = best_model.get("model_id", "") if best_model else "zzz"
            if current_id < best_id:
                is_better = True
        
        if is_better:
            best_score = score
            best_model = model
            
    selected_id = best_model["model_id"] if best_model else "genel_dengeli_v1"
    
    return {
        "selected_model_id": selected_id,
        "score": best_score,
        "candidates_considered": len(catalog),
        "reason": "taslak: yetenek puanlamasina gore secildi"
    }
